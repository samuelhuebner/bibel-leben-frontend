import { Injectable } from '@angular/core';
import { AngularFireAuth } from '@angular/fire/auth';
import { AngularFirestore } from '@angular/fire/firestore';
import { BehaviorSubject, Observable } from 'rxjs';
import { ActivatedRoute, Router } from '@angular/router';

import firebase from 'firebase/app';

import { bl19personOwn } from '../models/bl.models';
import { environment } from 'src/environments/environment';

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private user: Observable<firebase.User>;
  private currentUserData: BehaviorSubject<bl19personOwn>;
  private loggedIn = new BehaviorSubject<boolean>(false);

  constructor(
    private firebaseAuth: AngularFireAuth,
    private angularFirestore: AngularFirestore,
    private router: Router,
    private route: ActivatedRoute
  ) {
    this.loggedIn = new BehaviorSubject(Boolean(this.firebaseAuth.authState));
    this.currentUserData = new BehaviorSubject(null);

    this.user = this.firebaseAuth.user;

    this.user.subscribe((value) => {
      // if no uid is present no user is logged in so we have to return
      if (!value?.uid) {
        if (environment.debug) {
          console.log('auth-service: subscribtion: user is not logged in');
        }
        this.loggedIn.next(false);
        this.currentUserData.next(null);
        return;
      }

      if (environment.debug) {
        console.log('auth-service: subscription: user is logged in');
      }
      this.loggedIn.next(true);

      if (!this.currentUserData.value) {
        this.downloadUserData(value.uid);
      }
    });
  }

  /**
   * Function which downloads a users data given its UID and sets it to currentUserData
   */
  public async downloadUserData(uid: string): Promise<void> {
    const userPath = `users/u_default_groups/own_data/${uid}`;
    const userRef = this.angularFirestore.doc<any>(userPath);

    try {
      const userData = await userRef.get().toPromise();
      this.currentUserData.next(userData.data());
    } catch (error) {
      if (environment.debug) {
        console.error('auth-service: error downloading user-data');
      }
    }
  }

  /**
   * Function that provides an external auth provider login window.
   * Currently implemented providers:
   * - google
   *
   * If the provided provider is not implemented an error is thrown
   *
   * @param provider      The login provider
   */
  public async providerLogin(provider: string): Promise<firebase.auth.UserCredential> {
    switch (provider) {
      case 'google': {
        const google = new firebase.auth.GoogleAuthProvider();
        google.addScope('profile');
        google.addScope('email');

        const googleLogin = await this.firebaseAuth.signInWithPopup(google);

        this.loggedIn.next(true);
        const returnUrl = this.route.snapshot.queryParams.retUrl || 'home';
        this.router.navigate([returnUrl]);
        return googleLogin;
      }
      default: {
        throw new Error(`auth-service: ${provider} not avaliable`);
      }
    }
  }

  /**
   * Function which registers a new user in firebase
   *
   * @param email         The email of the registering user
   * @param password      The password of the registering user
   */
  public async register(email: string, password: string): Promise<firebase.auth.UserCredential> {
    const userCredential = await this.firebaseAuth.createUserWithEmailAndPassword(email, password);
    const returnUrl = this.route.snapshot.queryParams.retUrl || 'auth';
    this.router.navigate([returnUrl]);
    return userCredential;
  }

  /**
   * Function which signs in an existing user
   *
   * @param email         The email of the user
   * @param password      The password of the user
   */
  public async login(email: string, password: string): Promise<firebase.auth.UserCredential> {
    const userCredential = await this.firebaseAuth.signInWithEmailAndPassword(email, password);
    this.loggedIn.next(true);

    const returnUrl = this.route.snapshot.queryParams.retUrl || 'home';
    this.router.navigate([returnUrl]);
    return userCredential;
  }

  /**
   * Function which sends a password reset message to the provided email-address
   * @param email         The email of the user
   */
  public resetPassword(email: string): Promise<void> {
    return this.firebaseAuth.sendPasswordResetEmail(email);
  }

  /**
   * Function which confirms a password reset with the code and the new password
   *
   * @param code          The code generated by the passwordReset
   * @param password      The new password of the user
   */
  public confirmPasswordReset(code: string, password: string): Promise<void> {
    return this.firebaseAuth.confirmPasswordReset(code, password);
  }

  /**
   * Function that signsOut a user. Throws an error when no user was logged in
   */
  public async logout(): Promise<void> {
    if (!this.firebaseAuth.user) {
      throw new Error('auth-service: no user to logout');
    }

    await this.firebaseAuth.signOut();
    this.currentUserData.next(null);
    this.loggedIn.next(false);

    switch (this.router.url) {
      case '/profile':
          this.router.navigate(['auth'])
          break;
      default:
          this.router.navigate(['home']);
          break;
  }
  }

  /**
   * returns the current user-data
   */
  public getUser(): bl19personOwn {
    return this.currentUserData.value;
  }

  /**
   * returns the firebase user object as an Observable
   */
  public getUserObs(): Observable<firebase.User> {
    return this.firebaseAuth.authState;
  }

  /**
   * returns the current user data as an observable
   */
  public getUserDataObservable(): Observable<bl19personOwn> {
    return this.currentUserData.asObservable();
  }

  /**
   * returns the current user data as raw data
   */
  public getUserData(): bl19personOwnÂ {
    return this.currentUserData;
  }

  /**
   * Gets logged in status as BehaviorSubject
   */
  public isLoggedIn(): BehaviorSubject<boolean> {
    return this.loggedIn;
  }
}
